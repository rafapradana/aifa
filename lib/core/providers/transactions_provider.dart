import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/transaction.dart';
import 'auth_provider.dart';

class TransactionsNotifier
    extends StateNotifier<AsyncValue<List<Transaction>>> {
  TransactionsNotifier(this._supabase) : super(const AsyncValue.loading());

  final SupabaseClient _supabase;

  Future<void> loadTransactions() async {
    state = const AsyncValue.loading();
    try {
      final user = _supabase.auth.currentUser;
      if (user == null) {
        state = const AsyncValue.data([]);
        return;
      }

      final response = await _supabase
          .from('transactions')
          .select()
          .eq('user_id', user.id)
          .order('date', ascending: false)
          .order('created_at', ascending: false);

      final transactions =
          (response as List).map((json) => Transaction.fromJson(json)).toList();

      state = AsyncValue.data(transactions);
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  Future<void> addTransaction({
    required double amount,
    required TransactionType type,
    required String category,
    String? description,
    required DateTime date,
  }) async {
    try {
      final user = _supabase.auth.currentUser;
      if (user == null) throw Exception('User not authenticated');

      final transaction = Transaction(
        id: '', // Will be generated by database
        userId: user.id,
        amount: amount,
        type: type,
        category: category,
        description: description,
        date: date,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      await _supabase.from('transactions').insert(transaction.toJson());
      await loadTransactions(); // Reload to get updated list
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  Future<void> updateTransaction(Transaction transaction) async {
    try {
      final updatedTransaction = transaction.copyWith(
        updatedAt: DateTime.now(),
      );

      await _supabase
          .from('transactions')
          .update(updatedTransaction.toJson())
          .eq('id', transaction.id);

      await loadTransactions(); // Reload to get updated list
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  Future<void> deleteTransaction(String transactionId) async {
    try {
      await _supabase.from('transactions').delete().eq('id', transactionId);

      await loadTransactions(); // Reload to get updated list
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  Future<List<Transaction>> getTransactionsByDateRange({
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      final user = _supabase.auth.currentUser;
      if (user == null) return [];

      final response = await _supabase
          .from('transactions')
          .select()
          .eq('user_id', user.id)
          .gte('date', startDate.toIso8601String().split('T')[0])
          .lte('date', endDate.toIso8601String().split('T')[0])
          .order('date', ascending: false);

      return (response as List)
          .map((json) => Transaction.fromJson(json))
          .toList();
    } catch (error) {
      throw Exception('Failed to load transactions: $error');
    }
  }

  Future<Map<String, double>> getCategoryTotals({
    required DateTime startDate,
    required DateTime endDate,
    TransactionType? type,
  }) async {
    try {
      final transactions = await getTransactionsByDateRange(
        startDate: startDate,
        endDate: endDate,
      );

      final filteredTransactions =
          type != null
              ? transactions.where((t) => t.type == type).toList()
              : transactions;

      final categoryTotals = <String, double>{};
      for (final transaction in filteredTransactions) {
        categoryTotals[transaction.category] =
            (categoryTotals[transaction.category] ?? 0) + transaction.amount;
      }

      return categoryTotals;
    } catch (error) {
      throw Exception('Failed to calculate category totals: $error');
    }
  }

  Future<List<Transaction>> searchTransactions({
    String? searchQuery,
    String? category,
    TransactionType? type,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      final user = _supabase.auth.currentUser;
      if (user == null) return [];

      var query = _supabase
          .from('transactions')
          .select()
          .eq('user_id', user.id);

      // Apply filters
      if (category != null && category.isNotEmpty) {
        query = query.eq('category', category);
      }

      if (type != null) {
        query = query.eq('type', type.toString().split('.').last);
      }

      if (startDate != null) {
        query = query.gte('date', startDate.toIso8601String().split('T')[0]);
      }

      if (endDate != null) {
        query = query.lte('date', endDate.toIso8601String().split('T')[0]);
      }

      final response = await query.order('date', ascending: false);
      var transactions =
          (response as List).map((json) => Transaction.fromJson(json)).toList();

      // Apply text search filter
      if (searchQuery != null && searchQuery.isNotEmpty) {
        transactions =
            transactions.where((transaction) {
              final description = transaction.description?.toLowerCase() ?? '';
              final category = transaction.category.toLowerCase();
              final query = searchQuery.toLowerCase();

              return description.contains(query) || category.contains(query);
            }).toList();
      }

      return transactions;
    } catch (error) {
      throw Exception('Failed to search transactions: $error');
    }
  }

  Future<Map<String, dynamic>> getTransactionStats({
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      final now = DateTime.now();
      final start = startDate ?? DateTime(now.year, now.month, 1);
      final end = endDate ?? DateTime(now.year, now.month + 1, 0);

      final transactions = await getTransactionsByDateRange(
        startDate: start,
        endDate: end,
      );

      double totalIncome = 0;
      double totalExpenses = 0;
      int incomeCount = 0;
      int expenseCount = 0;
      double largestExpense = 0;
      double largestIncome = 0;
      String topExpenseCategory = '';
      double topExpenseCategoryAmount = 0;

      final Map<String, double> categoryTotals = {};

      for (final transaction in transactions) {
        if (transaction.type == TransactionType.income) {
          totalIncome += transaction.amount;
          incomeCount++;
          if (transaction.amount > largestIncome) {
            largestIncome = transaction.amount;
          }
        } else {
          totalExpenses += transaction.amount;
          expenseCount++;
          if (transaction.amount > largestExpense) {
            largestExpense = transaction.amount;
          }

          // Track category totals for expenses
          categoryTotals[transaction.category] =
              (categoryTotals[transaction.category] ?? 0) + transaction.amount;
        }
      }

      // Find top expense category
      if (categoryTotals.isNotEmpty) {
        final topCategory = categoryTotals.entries.reduce(
          (a, b) => a.value > b.value ? a : b,
        );
        topExpenseCategory = topCategory.key;
        topExpenseCategoryAmount = topCategory.value;
      }

      return {
        'totalIncome': totalIncome,
        'totalExpenses': totalExpenses,
        'netIncome': totalIncome - totalExpenses,
        'incomeCount': incomeCount,
        'expenseCount': expenseCount,
        'totalTransactions': transactions.length,
        'largestExpense': largestExpense,
        'largestIncome': largestIncome,
        'averageExpense': expenseCount > 0 ? totalExpenses / expenseCount : 0,
        'averageIncome': incomeCount > 0 ? totalIncome / incomeCount : 0,
        'topExpenseCategory': topExpenseCategory,
        'topExpenseCategoryAmount': topExpenseCategoryAmount,
        'savingsRate':
            totalIncome > 0
                ? ((totalIncome - totalExpenses) / totalIncome) * 100
                : 0,
      };
    } catch (error) {
      throw Exception('Failed to calculate transaction stats: $error');
    }
  }

  Future<List<String>> getUniqueCategories({TransactionType? type}) async {
    try {
      final user = _supabase.auth.currentUser;
      if (user == null) return [];

      var query = _supabase
          .from('transactions')
          .select('category')
          .eq('user_id', user.id);

      if (type != null) {
        query = query.eq('type', type.toString().split('.').last);
      }

      final response = await query;
      final categories =
          (response as List)
              .map((item) => item['category'] as String)
              .toSet()
              .toList();

      categories.sort();
      return categories;
    } catch (error) {
      throw Exception('Failed to get categories: $error');
    }
  }

  void clearTransactions() {
    state = const AsyncValue.data([]);
  }
}

final transactionsProvider =
    StateNotifierProvider<TransactionsNotifier, AsyncValue<List<Transaction>>>((
      ref,
    ) {
      final supabase = ref.watch(supabaseClientProvider);
      final notifier = TransactionsNotifier(supabase);

      // Load transactions when auth state changes
      ref.listen(authStateProvider, (previous, next) {
        next.whenData((authState) {
          if (authState.session?.user != null) {
            notifier.loadTransactions();
          } else {
            notifier.clearTransactions();
          }
        });
      });

      return notifier;
    });

// Provider for current month transactions
final currentMonthTransactionsProvider =
    Provider<AsyncValue<List<Transaction>>>((ref) {
      final allTransactions = ref.watch(transactionsProvider);

      return allTransactions.when(
        data: (transactions) {
          final now = DateTime.now();
          final startOfMonth = DateTime(now.year, now.month, 1);
          final endOfMonth = DateTime(now.year, now.month + 1, 0);

          final currentMonthTransactions =
              transactions.where((transaction) {
                return transaction.date.isAfter(
                      startOfMonth.subtract(const Duration(days: 1)),
                    ) &&
                    transaction.date.isBefore(
                      endOfMonth.add(const Duration(days: 1)),
                    );
              }).toList();

          return AsyncValue.data(currentMonthTransactions);
        },
        loading: () => const AsyncValue.loading(),
        error: (error, stackTrace) => AsyncValue.error(error, stackTrace),
      );
    });

// Provider for monthly income and expense totals
final monthlyTotalsProvider = Provider<AsyncValue<Map<String, double>>>((ref) {
  final currentMonthTransactions = ref.watch(currentMonthTransactionsProvider);

  return currentMonthTransactions.when(
    data: (transactions) {
      double totalIncome = 0;
      double totalExpenses = 0;

      for (final transaction in transactions) {
        if (transaction.type == TransactionType.income) {
          totalIncome += transaction.amount;
        } else {
          totalExpenses += transaction.amount;
        }
      }

      return AsyncValue.data({
        'income': totalIncome,
        'expenses': totalExpenses,
        'balance': totalIncome - totalExpenses,
      });
    },
    loading: () => const AsyncValue.loading(),
    error: (error, stackTrace) => AsyncValue.error(error, stackTrace),
  );
});

// Provider for transaction statistics
final transactionStatsProvider = FutureProvider<Map<String, dynamic>>((
  ref,
) async {
  final transactionsNotifier = ref.watch(transactionsProvider.notifier);
  return await transactionsNotifier.getTransactionStats();
});

// Provider for unique categories
final uniqueCategoriesProvider =
    FutureProvider.family<List<String>, TransactionType?>((ref, type) async {
      final transactionsNotifier = ref.watch(transactionsProvider.notifier);
      return await transactionsNotifier.getUniqueCategories(type: type);
    });

// Provider for expense categories only
final expenseCategoriesProvider = FutureProvider<List<String>>((ref) async {
  final transactionsNotifier = ref.watch(transactionsProvider.notifier);
  return await transactionsNotifier.getUniqueCategories(
    type: TransactionType.expense,
  );
});

// Provider for income categories only
final incomeCategoriesProvider = FutureProvider<List<String>>((ref) async {
  final transactionsNotifier = ref.watch(transactionsProvider.notifier);
  return await transactionsNotifier.getUniqueCategories(
    type: TransactionType.income,
  );
});
