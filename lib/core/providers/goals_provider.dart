import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/goal.dart';
import 'auth_provider.dart';

class GoalsNotifier extends StateNotifier<AsyncValue<List<Goal>>> {
  GoalsNotifier(this._supabase) : super(const AsyncValue.loading());

  final SupabaseClient _supabase;

  Future<void> loadGoals() async {
    state = const AsyncValue.loading();
    try {
      final user = _supabase.auth.currentUser;
      if (user == null) {
        state = const AsyncValue.data([]);
        return;
      }

      final response = await _supabase
          .from('goals')
          .select()
          .eq('user_id', user.id)
          .order('created_at', ascending: false);

      final goals =
          (response as List).map((json) => Goal.fromJson(json)).toList();

      state = AsyncValue.data(goals);
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  Future<void> createGoal({
    required String title,
    required double targetAmount,
    DateTime? deadline,
  }) async {
    try {
      final user = _supabase.auth.currentUser;
      if (user == null) throw Exception('User not authenticated');

      final goal = Goal(
        id: '', // Will be generated by database
        userId: user.id,
        title: title,
        targetAmount: targetAmount,
        deadline: deadline,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      await _supabase.from('goals').insert(goal.toJson());
      await loadGoals();
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  Future<void> updateGoal(Goal goal) async {
    try {
      final updatedGoal = goal.copyWith(updatedAt: DateTime.now());

      await _supabase
          .from('goals')
          .update(updatedGoal.toJson())
          .eq('id', goal.id);

      await loadGoals();
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  Future<void> addMoneyToGoal({
    required String goalId,
    required double amount,
  }) async {
    try {
      // Get current goal
      final response =
          await _supabase.from('goals').select().eq('id', goalId).single();

      final goal = Goal.fromJson(response);
      final newAmount = goal.currentAmount + amount;

      await _supabase
          .from('goals')
          .update({
            'current_amount': newAmount,
            'updated_at': DateTime.now().toIso8601String(),
          })
          .eq('id', goalId);

      await loadGoals();
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  Future<void> deleteGoal(String goalId) async {
    try {
      await _supabase.from('goals').delete().eq('id', goalId);

      await loadGoals();
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  Future<Map<String, double>> getGoalsSummary() async {
    try {
      final user = _supabase.auth.currentUser;
      if (user == null) return {};

      final response = await _supabase
          .from('goals')
          .select()
          .eq('user_id', user.id);

      final goals =
          (response as List).map((json) => Goal.fromJson(json)).toList();

      double totalTarget = 0;
      double totalSaved = 0;
      int completedGoals = 0;
      int urgentGoals = 0;
      double averageProgress = 0;

      for (final goal in goals) {
        totalTarget += goal.targetAmount;
        totalSaved += goal.currentAmount;

        if (goal.isCompleted) {
          completedGoals++;
        }

        // Check if goal is urgent (deadline within 30 days)
        if (goal.deadline != null) {
          final daysUntilDeadline =
              goal.deadline!.difference(DateTime.now()).inDays;
          if (daysUntilDeadline <= 30 &&
              daysUntilDeadline > 0 &&
              !goal.isCompleted) {
            urgentGoals++;
          }
        }

        // Calculate individual progress
        if (goal.targetAmount > 0) {
          averageProgress += (goal.currentAmount / goal.targetAmount) * 100;
        }
      }

      if (goals.isNotEmpty) {
        averageProgress = averageProgress / goals.length;
      }

      return {
        'totalTarget': totalTarget,
        'totalSaved': totalSaved,
        'overallProgress':
            totalTarget > 0 ? (totalSaved / totalTarget) * 100 : 0,
        'averageProgress': averageProgress,
        'completedGoals': completedGoals.toDouble(),
        'totalGoals': goals.length.toDouble(),
        'urgentGoals': urgentGoals.toDouble(),
        'completionRate':
            goals.isNotEmpty ? (completedGoals / goals.length) * 100 : 0,
      };
    } catch (error) {
      throw Exception('Failed to calculate goals summary: $error');
    }
  }

  Future<Map<String, dynamic>> getGoalProgress(String goalId) async {
    try {
      final response =
          await _supabase.from('goals').select().eq('id', goalId).single();

      final goal = Goal.fromJson(response);

      final progress =
          goal.targetAmount > 0
              ? (goal.currentAmount / goal.targetAmount) * 100
              : 0;

      final remaining = goal.targetAmount - goal.currentAmount;

      // Calculate suggested monthly/weekly savings
      double suggestedMonthlySaving = 0;
      double suggestedWeeklySaving = 0;
      int daysRemaining = 0;

      if (goal.deadline != null && !goal.isCompleted) {
        daysRemaining = goal.deadline!.difference(DateTime.now()).inDays;
        if (daysRemaining > 0) {
          final monthsRemaining = daysRemaining / 30.0;
          final weeksRemaining = daysRemaining / 7.0;

          if (monthsRemaining > 0) {
            suggestedMonthlySaving = remaining / monthsRemaining;
          }
          if (weeksRemaining > 0) {
            suggestedWeeklySaving = remaining / weeksRemaining;
          }
        }
      }

      return {
        'goal': goal,
        'progress': progress,
        'remaining': remaining,
        'daysRemaining': daysRemaining,
        'suggestedMonthlySaving': suggestedMonthlySaving,
        'suggestedWeeklySaving': suggestedWeeklySaving,
        'isUrgent': daysRemaining <= 30 && daysRemaining > 0,
        'isOverdue': daysRemaining < 0,
      };
    } catch (error) {
      throw Exception('Failed to calculate goal progress: $error');
    }
  }

  Future<List<String>> getGoalReminders() async {
    try {
      final user = _supabase.auth.currentUser;
      if (user == null) return [];

      final response = await _supabase
          .from('goals')
          .select()
          .eq('user_id', user.id);

      final goals =
          (response as List).map((json) => Goal.fromJson(json)).toList();
      final List<String> reminders = [];

      for (final goal in goals) {
        if (goal.isCompleted) continue;

        final progress =
            goal.targetAmount > 0
                ? (goal.currentAmount / goal.targetAmount) * 100
                : 0;

        if (goal.deadline != null) {
          final daysRemaining =
              goal.deadline!.difference(DateTime.now()).inDays;

          if (daysRemaining < 0) {
            reminders.add('ðŸ”´ ${goal.title}: Goal deadline passed');
          } else if (daysRemaining <= 7) {
            reminders.add('ðŸ”´ ${goal.title}: Only $daysRemaining days left!');
          } else if (daysRemaining <= 30) {
            reminders.add('ðŸŸ¡ ${goal.title}: $daysRemaining days remaining');
          }
        }

        // Progress-based reminders
        if (progress >= 90) {
          reminders.add(
            'ðŸŽ‰ ${goal.title}: Almost there! ${progress.toStringAsFixed(0)}% complete',
          );
        } else if (progress >= 75) {
          reminders.add(
            'ðŸ’ª ${goal.title}: Great progress! ${progress.toStringAsFixed(0)}% complete',
          );
        } else if (progress < 25 && goal.deadline != null) {
          final daysRemaining =
              goal.deadline!.difference(DateTime.now()).inDays;
          if (daysRemaining <= 60) {
            reminders.add('âš ï¸ ${goal.title}: Consider increasing savings rate');
          }
        }
      }

      return reminders;
    } catch (error) {
      throw Exception('Failed to generate goal reminders: $error');
    }
  }

  List<Goal> getActiveGoals() {
    return state.maybeWhen(
      data: (goals) => goals.where((goal) => !goal.isCompleted).toList(),
      orElse: () => [],
    );
  }

  List<Goal> getCompletedGoals() {
    return state.maybeWhen(
      data: (goals) => goals.where((goal) => goal.isCompleted).toList(),
      orElse: () => [],
    );
  }

  void clearGoals() {
    state = const AsyncValue.data([]);
  }
}

final goalsProvider =
    StateNotifierProvider<GoalsNotifier, AsyncValue<List<Goal>>>((ref) {
      final supabase = ref.watch(supabaseClientProvider);
      final notifier = GoalsNotifier(supabase);

      // Load goals when auth state changes
      ref.listen(authStateProvider, (previous, next) {
        next.whenData((authState) {
          if (authState.session?.user != null) {
            notifier.loadGoals();
          } else {
            notifier.clearGoals();
          }
        });
      });

      return notifier;
    });

// Provider for goals summary
final goalsSummaryProvider = FutureProvider<Map<String, double>>((ref) async {
  final goalsNotifier = ref.watch(goalsProvider.notifier);
  return await goalsNotifier.getGoalsSummary();
});

// Provider for active goals
final activeGoalsProvider = Provider<List<Goal>>((ref) {
  final goalsNotifier = ref.watch(goalsProvider.notifier);
  return goalsNotifier.getActiveGoals();
});

// Provider for completed goals
final completedGoalsProvider = Provider<List<Goal>>((ref) {
  final goalsNotifier = ref.watch(goalsProvider.notifier);
  return goalsNotifier.getCompletedGoals();
});

// Provider for goal progress by ID
final goalProgressProvider =
    FutureProvider.family<Map<String, dynamic>, String>((ref, goalId) async {
      final goalsNotifier = ref.watch(goalsProvider.notifier);
      return await goalsNotifier.getGoalProgress(goalId);
    });

// Provider for goal reminders
final goalRemindersProvider = FutureProvider<List<String>>((ref) async {
  final goalsNotifier = ref.watch(goalsProvider.notifier);
  return await goalsNotifier.getGoalReminders();
});
